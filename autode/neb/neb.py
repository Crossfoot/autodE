import autode.exceptions as ex
from autode.config import Config
from autode.log import logger
from autode.calculation import Calculation
from autode.neb.original import NEB
from autode.methods import get_lmethod
from autode.transition_states.ts_guess import get_ts_guess


def get_ts_guess_neb(reactant, product, method, fbonds=None, bbonds=None,
                     name='neb',
                     n=8, generate_final_species=True):
    """
    Get a transition state guess using a nudged elastic band calculation. The
    geometry of the reactant is used as the fixed initial point and the final
    product geometry generated by driving a linear path to products, which is
    used as the initial guess for the NEB images

    Arguments:
        reactant (autode.species.Species):
        product (autode.species.Species):
        method (autode.wrappers.base.ElectronicStructureMethod):

    Keyword Arguments:
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        name (str):
        n (int): Number of images to use in the NEB
        generate_final_species (bool):

    """
    logger.info('Generating a TS guess using a nudged elastic band')

    neb = NEB(num=n)

    if generate_final_species:

        try:
            species_set = get_linear_species_set(reactant, fbonds, bbonds, n=n,
                                                 end_method=method)
            for i, image in enumerate(neb.images):
                image.species = species_set[i]

        except ex.AtomsNotFound:
            logger.error('Failed to locate linear path')
            return None

    # Otherwise using the reactant and product geometries
    else:
        neb.images[0].species = reactant.copy()
        neb.images[-1].species = product.copy()
        neb.interpolate_geometries()

    # Calculate and generate the TS guess
    try:
        neb.calculate(method=method, n_cores=Config.n_cores)

    except ex.CouldNotGetProperty:
        logger.error('NEB failed')
        return None

    for peak_species in neb.get_species_saddle_point():
        return get_ts_guess(peak_species, reactant, product, name=name)

    logger.warning('NEB did not generate a saddle point')
    return None


def get_linear_species_set(initial_species, fbonds, bbonds, n,
                           end_method=None,
                           intermediate_method=None):
    """
    Generate the end point on the NEB by running a 1D

    Arguments:
        initial_species (autode.species.Species):
        fbonds (list(autode.pes.pes.FormingBond)):
        bbonds (list(autode.pes.pes.BreakingBond)):
        n (int): Number of intermediate species to generate between the initial
                 and final species

    Keyword Arguments:
        end_method (autode.wrappers.base.ElectronicStructureMethod):
        intermediate_method (autode.wrappers.base.ElectronicStructureMethod):
    """
    assert fbonds is not None and bbonds is not None

    # Calculate the uniform change in each bond distance from initial -> final
    deltas = [(b.final_dist - b.curr_dist)/(n-1) for b in fbonds + bbonds]

    # Set a dictionary of bond length constraints
    consts = {b.atom_indexes: b.curr_dist for b in fbonds + bbonds}

    species_set = []

    # Generate a species with a constrained geometry for each point in the path
    for i in range(n):

        if i == 0:
            species = initial_species.copy()

        else:
            species = species_set[i-1].copy()

            # Add the required change in every bond length to get to the final
            # distances at step n-1
            for j, atom_indexes in enumerate(consts.keys()):
                consts[atom_indexes] += deltas[j]

        # Run the constrained optimisation
        if end_method is not None and (i == 0 or i == n-1):
            method = end_method

        elif intermediate_method is not None:
            method = intermediate_method

        else:
            method = get_lmethod()

        opt = Calculation(name=f'{species.name}_constrained_opt{i}',
                          molecule=species,
                          method=method,
                          keywords=method.keywords.opt,
                          n_cores=Config.n_cores,
                          distance_constraints=consts)
        opt.run()

        # Set the optimised atoms - can raise AtomsNotFound
        species.set_atoms(atoms=opt.get_final_atoms())
        species.energy = opt.get_energy()
        species_set.append(species)

    return species_set
